<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/CSS-Files/style.css">
    <link rel="stylesheet" href="/CSS-Files/codingColors.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

      
    <div class="navbar">
        <div class="container-navbar1">
            <a href="/index.html">Home</a>
            <a href="">CSS</a>
            <a href="/HTML/htmlFirst.html">HTML</a>
        </div>  
    </div>

    <div>
        <div class="main-container">
           
           
        </div>

     <!--  <span class="darkBlue">const</span>          &lt; h1 &gt;  Hello world&lt;/h1&gt;   -->
            <div class="javascript-body">

                <div>
                    <h2>useEffect</h2>
                    <p>The Effect Hook tells our component to do something every time it’s rendered (or re-rendered). Combined with states, we can use the Effect Hook to create interesting dynamic changes in our web pages!</p>
                    <h3>When to use useEffect?</h3>
                    <ul>
                            <li>Fetching data from an API.</li>
                            <li>Directly manipulating the DOM (like updating the document title).</li>
                            <li>Setting up subscriptions or timers.</li>
                            <li>Logging to the console.</li>
                    </ul>
                </div>
    
                <div class="">
                    <h4>Running Effects: You can specify when the effect should run:</h4>
                    <ul>
                        <li>After every render (default behavior).</li>
                        <li>Only on mount and unmount.</li>
                        <li>Only when certain values change.</li>
                    </ul>
    
                    <h4>What is render?</h4>
                    <p>n React, a render refers to the process of creating or updating the UI based on the current state and props of a component.
    
                        Whenever the state or props of a component change (like when the user clicks a button and the count updates), React re-renders that component.</p>
                </div>
    
                <h3>Syntax</h3>
    
                <div class="blackCoding">
                    <p>
                        useEffect(() => { <br>
                            <span class="lightGreen">//// Your code here (side effect)</span> <br>
                          <br>
                            return () => { <br>
                              <span class="lightGreen">/// Cleanup code here (if needed)</span><br> <br>
                            }; <br>
                          }, [dependencies]); <br>
                          
                    </p>
                </div>
                <h3>Whats Cleanup?</h3>
                <p></p>
    
                <div class="blackCoding">
                    <p>
                        useEffect(() => { <br>
                            <span class="lightGreen">//When you use useEffect, you can return a function from it, which acts as a cleanup routin</span> <br>
                            const timer = setTimeout(() => { <br>
                              console.log("Timer executed"); <br>
                            }, 1000); <br>
                          <br>
                            return () => { <br>
                              clearTimeout(timer); <span class="lightGreen">// Cleanup function</span> <br>
                            }; <br>
                          }, []); <br>
                          
                    </p>
                </div>
    
                <h3>Subscribing to an Event</h3>
    
                <div class="blackCoding">
                    <p>
                        import React, { useEffect } from 'react'; <br>
    <br>
                        const WindowResizeComponent = () => { <br>
                        const handleResize = () => { <br>
                    <span class="black">---</span>        console.log('Window resized:', window.innerWidth); <br>
                        }; <br>
    <br>
                        useEffect(() => { <br>
                            <span class="black">---</span>      window.addEventListener('resize', handleResize); <br>
    <br>
                            <span class="lightGreen">// Cleanup function</span> <br>
                            <span class="black">---</span>      return () => { <br>
                                <span class="black">---</span>      window.removeEventListener('resize', handleResize); <br>
                                <span class="black">---</span>       }; <br>
                        }, []); <span class="lightGreen">// Runs once on mount</span> <br>
    <br>
                        return &lt;div&gt;Resize the window and check the console!&lt;/div&gt;; <br>
                        }; <br>
    
                    </p>
                </div>
    
                <h3> Understanding Dependencies</h3>
                <p>When you pass dependencies to the dependency array, the effect will re-run only if one of those dependencies changes. Make sure to include all values that the effect uses from the component’s scope to avoid stale closures. Omitting a dependency can lead to bugs that are hard to track down.</p>
    
                <div class="blackCoding">
                    <p>
    
                    </p>
                </div>
    
                <h3>Running Effects on State Changes</h3>
                <p>You can also specify dependencies so that the effect runs only when certain values change:</p>
    
                <div class="blackCoding">
                    <p>
                        
    
    
                    import React, { useState, useEffect } from 'react'; <br>
                    <br>
                    const Counter = () => { <br>            
                    const [count, setCount] = useState(0); <br>
                    const [name, setName] = useState(''); <br>
                    <br>
                    <span class="lightGreen">// Effect to update the document title when count changes</span> <br>
                    useEffect(() => { <br>                
                        document.title = `Count: ${count}`; <br>    
                    }, [count]); // Only runs when `count` changes <br>
                    <br>
                    <span class="lightGreen">// Effect to log a message whenever the name changes</span> <br>
                    useEffect(() => { <br>
                        console.log(`Name changed to: ${name}`); <br>
                    }, [name]); <span class="lightGreen">// Only runs when `name` changes </span><br>
                    <br>
                    const handleIncrement = () => { <br>
                        setCount(prevCount => prevCount + 1); <br>
                    }; <br>
                    <br>
                    const handleNameChange = (event) => { <br>
                        setName(event.target.value); <br>
                    }; <br>
                    <br>
                    return ( <br>
                        &lt;div&gt; <br>
                        &lt;h1>Count: {count}&lt;/h1&gt; <br>                           
                        &lt;button onClick={handleIncrement}>Increment&lt;/button&gt; <br>
                    <br>
                        &lt;h2>Change Name&lt;/h2&gt; <br>
                        &lt;input type="text" value={name} onChange={handleNameChange} /&gt; <br>
                        &lt;/div&gt; <br>
                    ); <br>
                    }; <br>
                    <br>                    
                    export default Counter; <br>
    
                    </p>
                </div>
    
                <h3>Example of useEffect</h3>
                <p>Everytime we render the Count variable, it will be displayed in the console, (That is the side Effect) </p>
                <div class="blackCoding">
                    <p>
                        import React, { useState, useEffect } from 'react'; <br>
    <br>
                        const CounterComponent = () => { <br>   
                        const [count, setCount] = useState(0); <br>
    <br>
                        useEffect(() => { <br>                      
                            console.log(`Count changed: ${count}`); <br>
                        }, [count]); <span class="lightGreen">// Runs whenever `count` changes</span> <br>
    <br>
                        return ( <br>   
                            &lt;div&gt; <br>
                            &lt;p&gt;Count: {count}&lt;/p&gt; <br>
                            &lt;button onClick={() => setCount(count + 1)}>Increment&lt;/button&gt; <br>
                            &lt;/div&gt; <br>
                        ); <br>
                        }; <br>
    
                    </p>
                </div>

              <!-- <div class="blackCoding">
                <p>
                    import React, { useState, useEffect } from 'react'; <span class="lightGreen">//Importing useState and useEffect</span><br>
    <br>
                    export default function Counter() { <br>
                      const [count, setCount] = useState(0); <br>
                    <br>
                    useEffect (() => { <br>
                      alert(`Count: ${count}`) <span class="lightGreen">// Effect that runs whenever the count changes</span><br>
                    }) <span class="lightGreen">// <span class="red">NOTE</span> : This effect will run after every render because no dependency array is provided</span> <br>
                    <br>
                      const handleClick = () => {  <span class="lightGreen">//This function will help to keep track when we add 1</span><br>              
                        setCount((prevCount) =>  prevCount + 1); <span class="lightGreen">// Increment the count by 1 when the button is clicked</span><br>
                      }; <br>
                     <br>
                      return ( <br>
                        &lt;div> <br>
                        &lt;p>You clicked {count} times&lt;/p&gt; <br>
                        &lt;button onClick={handleClick}&gt; <br>
                            Click me <br>   
                            &lt;/button&gt; <br>
                            &lt;/div&gt; <br>
                      ); <br>
                    } <br>
    
                    
                    </p>
              </div> -->

            </div>

            <h3>Clean Up Effects</h3>
            <p>Some effects require cleanup. For example, we might want to add event listeners to some element in the DOM, beyond the JSX in our component. When we add event listeners to the DOM, it is important to remove those event listeners when we are done with them to avoid memory leaks!</p>

            <div class="blackCoding">
                   <!--  <span class="darkBlue">const</span>          &lt; h1 &gt;  Hello world&lt;/h1&gt;   -->
                <p>
                    import React, { useEffect, useState } from 'react'; <br>
<br>
                    export default function MouseTracker() { <br>                       
                    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 }); <br>
<br>                                    
                    useEffect(() => { <br>                      
                        <span class="lightGreen">// Function to update mouse position</span> <br>
                        const handleMouseMove = (event) => {  <br>                  
                        setMousePosition({ x: event.clientX, y: event.clientY }); <br>
                        }; <br>
 <br>
                        <span class="lightGreen">// Add event listener for mouse movement</span> <br>
                        window.addEventListener('mousemove', handleMouseMove); <br>
<br>
                        <span class="lightGreen">// Cleanup function to remove the event listener</span> <br>
                        return () => { <br>                                     
                        window.removeEventListener('mousemove', handleMouseMove); <br>
                        }; <br>
                    }, []); <span class="lightGreen">// Empty dependency array means this runs once on mount</span> <br>
 <br>
                    return ( <br>
                        &lt;div&gt; <br>                                             
                        &lt;h2>Mouse Position&lt;/h2&gt; <br>
                        &lt;p>X: {mousePosition.x}&lt;/p&gt; <br>
                        &lt;p>Y: {mousePosition.y}&lt;/p&gt; <br>
                        &lt;/div&gt; <br>
                    ); <br>
                    } <br>
                    <br>
                    <br>


                    import React, { useState, useEffect } from 'react'; <br>
<br>
                    export default function Counter() { <br>
                    <span class="lightGreen">// State to keep track of the click count</span> <br>
                    const [clickCount, setClickCount] = useState(0); <br>
<br>
                   <span class="lightGreen"> // Function to increment the click count</span> <br>
                    const increment = () => { <br>                      
                        setClickCount((prevCount) => prevCount + 1); <br>
                    }; <br>
<br>                                    
                    useEffect(() => { <br>                                                      
                       <span class="lightGreen"> // Add an event listener for 'mousedown' events on the document</span> <br>
                        document.addEventListener('mousedown', increment); <br>
<br>
                        <span class="lightGreen">// Cleanup function to remove the event listener when the component unmounts</span> <br>
                        return () => { <br>                                     
                        document.removeEventListener('mousedown', increment); <br>
                        }; <br>                                                                                 
                    }, []); <span class="lightGreen">// Empty dependency array means this effect runs once on mount</span> <br>
<br>
                    return ( <br>                               
                        <span class="lightGreen">// Display the current click count </span><br>                
                        &lt;h1&gt;Document Clicks: {clickCount}&lt;/h1&gt; <br>
                    ); <br>
                    } <br>
                </p>
            </div>

            <h3>Control When Effects Are Called <span class="red">FIX THIS!</span></h3>
            <p>Its common, when defining function components, to run an effect only when the component mounts (renders the first time), but not when the component re-renders. The Effect Hook makes this very easy for us to do</p>
            <p>If we want to only call our effect after the first render, we pass an empty array to useEffect()</p>
            <p>as the second argument. This second argument is called the dependency array. <span class="red">NOTE</span>: thats why in the example above, i have as the second parameter an empty []</p>
       
            <div class="blackCoding">
                <p>
                    useEffect(() => { <br>                              
                        document.title = `You clicked ${count} times`; <br>                         
                      }, [count]); // Only re-run the effect if the value stored by count changes <br>
                </p>
            </div>
            
       
            <h3>Fetch Data <span class="red">FIX THIS</span></h3>
            <p></p>
       
            <div class="blackCoding">
                <p>

                </p>
            </div>

            <h3>Rules of Hooks</h3>
            <p>Only call Hooks at the top level. <br>
                Only call Hooks from React functions.</p>

                <div class="blackCoding">
                    <p>

                    </p>
                </div>
       
                <h3>Separate Hooks for Separate Effects</h3>
                <p>When multiple values are closely related and change at the same time, it can make sense to group these values in a collection like an object or array. Packaging data together can also add complexity to the code responsible for managing that data. Therefore, it is a good idea to separate concerns by managing different data with different Hooks.</p>
                
                <div class="blackCoding">
                    <p>
                        <span class="red">FIX THIS</span>
                    </p>
                </div>

                
       
        </div>
</body>
</html>
